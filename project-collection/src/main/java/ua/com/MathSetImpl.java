package ua.com;import java.util.Iterator;import java.util.NoSuchElementException;public class MathSetImpl implements MathSet {    private static final int DEFAULT_CAPACITY = 16;    private int size = 0;    private Number[] numbers;    public MathSetImpl() {        this.numbers = new Number[DEFAULT_CAPACITY];    }    public MathSetImpl(int capacity) {        if (capacity <= 0) {            throw new IllegalArgumentException("Argument is not valid");        }        this.numbers = new Number[capacity];    }    public MathSetImpl(Number[] numbers) {        this.numbers = numbers;        size = numbers.length;    }    public MathSetImpl(Number[]... numbers) {        this.numbers = new Number[numbers.length];        for (Number[] number : numbers) {            add(number);        }    }    public MathSetImpl(MathSetImpl numbers) {        this.numbers = numbers.toArray();        size = numbers.toArray().length;    }    public MathSetImpl(MathSetImpl... numbers) {        this.numbers = new Number[DEFAULT_CAPACITY];        for (MathSetImpl array : numbers) {            add(array.toArray());        }    }    @Override    public void add(Number n) {        if (isNotContain(n)) {            checkSize();            numbers[size] = n;            size++;        }    }    @Override    public void add(Number... n) {        for (Number number : n) {            if (isNotContain(number)) {                add(number);            }        }    }    @Override    public void join(MathSetImpl ms) {        Number[] numbers = ms.toArray();        for (Number n : numbers) {            add(n);        }    }    @Override    public void sortDesc() {        sortDesc(0, size - 1);    }    @Override    public void sortDesc(int firstIndex, int lastIndex) {        isValid(firstIndex, lastIndex);        boolean isSorted = false;        Number buf;        while (!isSorted) {            isSorted = true;            for (int i = firstIndex; i < lastIndex; i++) {                if (numbers[i] != null && numbers[i + 1] != null) {                    if (numbers[i].doubleValue() < numbers[i + 1].doubleValue()) {                        isSorted = false;                        buf = numbers[i];                        numbers[i] = numbers[i + 1];                        numbers[i + 1] = buf;                    }                }            }        }    }    @Override    public void sortDesc(Number value) {        sortDesc(getIndex(value), size - 1);    }    @Override    public void sortAsc() {        sortAsc(0, size - 1);    }    @Override    public void sortAsc(int firstIndex, int lastIndex) {        isValid(firstIndex, lastIndex);        boolean isSorted = false;        Number buf;        while (!isSorted) {            isSorted = true;            for (int i = firstIndex; i < lastIndex; i++) {                if (numbers[i] != null && numbers[i + 1] != null) {                    if (numbers[i].doubleValue() > numbers[i + 1].doubleValue()) {                        isSorted = false;                        buf = numbers[i];                        numbers[i] = numbers[i + 1];                        numbers[i + 1] = buf;                    }                }            }        }    }    @Override    public void sortAsc(Number value) {        sortAsc(getIndex(value), size - 1);    }    @Override    public Number get(int index) {        if (index >= 0 && index < size) {            return numbers[index];        }        throw new IllegalArgumentException("Index is not valid");    }    @Override    public Number getMax() {        Number[] tempArray = numbers;        sortDesc();        Number max = numbers[0];        numbers = tempArray;        return max;    }    @Override    public Number getMin() {        Number[] tempArray = numbers;        sortAsc();        Number min = numbers[0];        numbers = tempArray;        return min;    }    @Override    public Number getAverage() {        double sum = 0;        for (Number n : numbers) {            if (n != null) {                sum += n.doubleValue();            }        }        return sum / size;    }    @Override    public Number getMedian() {        return (getMax().doubleValue() + getMin().doubleValue()) / 2;    }    @Override    public Number[] toArray() {        Number[] array = new Number[size];        System.arraycopy(numbers, 0, array, 0, size);        return array;    }    @Override    public Number[] toArray(int firstIndex, int lastIndex) {        isValid(firstIndex, lastIndex);        Number[] array = new Number[lastIndex - firstIndex + 1];        System.arraycopy(numbers, firstIndex, array, 0, array.length);        return array;    }    @Override    public MathSetImpl squash(int firstIndex, int lastIndex) {        isValid(firstIndex, lastIndex);        return new MathSetImpl(toArray(firstIndex, lastIndex));    }    @Override    public void clear() {        numbers = new Number[DEFAULT_CAPACITY];        size = 0;    }    @Override    public void clear(Number[] numbers) {        for (Number n : numbers) {            for (int i = 0; i < size; i++) {                if (n != null) {                    if (n.equals(this.numbers[i])) {                        this.numbers[i] = null;                    }                }            }        }    }    private void isValid(int firstIndex, int lastIndex) {        if (!(firstIndex >= 0 && firstIndex < size && firstIndex < lastIndex && lastIndex < size)) {            throw new IllegalArgumentException("Arguments is not valid");        }    }    private boolean isNotContain(Number number) {        boolean flag = true;        for (Number n : numbers) {            if (n != null) {                if (n.equals(number)) {                    flag = false;                    break;                }            }        }        return flag;    }    private void checkSize() {        if (numbers.length == size) {            resize();        }    }    private void resize() {        Number[] newArray = new Number[(numbers.length * 3) / 2 + 1];        System.arraycopy(numbers, 0, newArray, 0, size);        numbers = newArray;    }    private int getIndex(Number number) {        if (!isNotContain(number)) {            int i = 0;            for (int j = 0; j < numbers.length; j++) {                if (numbers[j] != null) {                    if (numbers[j].equals(number)) {                        i = j;                    }                }            }            return i;        }        throw new IllegalArgumentException("Number does not exist");    }    @Override    public Iterator<Number> iterator() {        return new Iterator<>() {            int index = 0;            @Override            public boolean hasNext() {                return index < size;            }            @Override            public Number next() {                if (hasNext()) {                    return numbers[index++];                }                throw new NoSuchElementException();            }        };    }}